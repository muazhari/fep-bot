{"version":3,"sources":["../../src/Bot/Bot.js"],"names":["line","shared_props","Bot","constructor","props","console","log"],"mappings":";;;;;;;AAAA;;;;AACA;;IAAYA,I;;AACZ;;AAUA;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AAEA;;;;;;;;AAEA;;AAEA;AACO,MAAMC,sCAAe,EAArB;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEO,MAAMC,GAAN,CAAU;AACfC,cAAYC,KAAZ,EAAmB;AACrB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEI;AACA;AACAC,YAAQC,GAAR,CAAY,eAAZ;AACA;AACD;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAjJiB;QAAJJ,G,GAAAA,G","file":"Bot.js","sourcesContent":["import Store from \"../Services/Store\";\nimport * as line from \"@line/bot-sdk\";\nimport {\n  FEPList,\n  StoreAdvance,\n  Basic,\n  Access,\n  Template,\n  Twibbon,\n  Courses,\n  PosetLattice\n} from \"./Features\";\nimport { DialogFlow } from \"./DialogFlow\";\nimport fs from \"fs-extra\";\nimport mkdirp from \"mkdirp\";\nimport path from \"path\";\nimport uuid from \"uuid\";\n\nimport config from \"../Config/Line\";\n\n// import handlerBot from \"./handlerBot\";\n\n// share worker props by groupId\nexport const shared_props = {};\n// export const listener_stack = {\n//   postback: {}\n// };\n\n// class listener {\n//   constructor(Bot){\n//     this.Bot = Bot\n//     this.event = this.Bot.props.event\n//   }\n\n//   push(callback){\n//     listener_stack[this.Bot.getId().user] = callback\n//   }\n\n//   postback(stringObject, callback) {\n//     const data = JSON.parse(stringObject)\n//     return callback(listener_stack.postback[uuid.v4])\n//   }\n// }\n\nexport class Bot {\n  constructor(props) {\n//     // console.log(shared_props)\n//     // only access by? user, group, room, origin\n//     this.props = this.initProps(props);\n//     // console.log(this.props)\n\n//     // create LINE SDK client\n//     this.client = new line.Client(config);\n\n//     // Features creator\n//     this.Features = {\n//       FEPList: FEPList(this),\n//       StoreAdvance: StoreAdvance(this),\n//       Basic: Basic(this),\n//       Access: Access(this),\n//       Template: Template(this),\n//       Twibbon: Twibbon(this),\n//       Courses: Courses(this),\n//       PosetLattice: PosetLattice(this)\n//     };\n\n//     // DialogFlow assist\n//     this.DialogFlow = new DialogFlow(this);\n\n    // Events listen assist\n    // this.listener = new listener(this)\n    console.log(\"Bot instanced\");\n    // new handlerBot(this);\n  }\n\n//   initProps(props) {\n//     const sourceIds = this.getId(props.event.source);\n\n//     Object.keys(sourceIds).map(type => {\n//       shared_props[sourceIds[type]] = {\n//         ...shared_props[sourceIds[type]],\n//         event: props.event\n//       };\n//     });\n\n//     return shared_props[sourceIds.origin];\n//   }\n\n//   profile() {\n//     return new Promise((resolve, reject) => {\n//       this.client\n//         .getProfile(this.getId().user)\n//         .then(resolve)\n//         .catch(reject);\n//     });\n//   }\n\n//   log() {\n//     Store.getStore(\"log_chat\").then(log_chat => {\n//       if (!log_chat || Object.keys(log_chat).length === 0) {\n//         log_chat = {\n//           groups: {},\n//           users: {}\n//         };\n//       }\n\n//       // switch (this.props.event.source.type) {\n//       // case 'user':\n//       //     const { userId } = this.props.event.source\n//       //     if (!log_chat['users'][userId]) {\n//       //       log_chat['users'][userId] = []\n//       //     }\n//       //     log_chat['user'][userId].push(this.props.event)\n//       //     return await Store.setStore({ log_chat: log_chat })\n//       // case 'group':\n//       //     const { groupId } = this.props.event.source\n//       //     if (!log_chat['groups'][groupId]) {\n//       //       log_chat['groups'][groupId] = []\n//       //     }\n//       //     log_chat['groups'][groupId].push(this.props.event)\n//       //     return await Store.setStore({ log_chat: log_chat })\n//       // }\n//     });\n//   }\n\n//   setProps(data, id) {\n//     console.log(data);\n//     if (!id) id = this.getId().origin;\n\n//     Object.keys(data).map(key => {\n//       this.shared_props[id][key] = data[key];\n//     });\n//   }\n\n//   getId(source) {\n//     if (!source) source = this.props.event.source;\n//     const type = {};\n\n//     if (source.groupId) {\n//       type[\"origin\"] = source.groupId;\n//     } else {\n//       if (source.roomId) {\n//         type[\"origin\"] = source.roomId;\n//       } else {\n//         if (source.userId) {\n//           type[\"origin\"] = source.userId;\n//         }\n//       }\n//     }\n\n//     if (source.groupId) {\n//       type[\"group\"] = source.groupId;\n//     }\n//     if (source.roomId) {\n//       type[\"room\"] = source.roomId;\n//     }\n//     if (source.userId) {\n//       type[\"user\"] = source.userId;\n//     }\n\n//     if (type) return type;\n//   }\n\n//   replyText(texts) {\n//     texts = Array.isArray(texts) ? texts : [texts];\n//     return this.client.replyMessage(\n//       this.props.event.replyToken,\n//       texts.map(text => ({ type: \"text\", text }))\n//     );\n//   }\n\n//   sendMessage(message) {\n//     message = Array.isArray(message) ? message : [message];\n//     return this.client.replyMessage(\n//       this.props.event.replyToken,\n//       message.map(msg => msg)\n//     );\n//   }\n\n//   downloadContent(messageId, downloadPath) {\n//     return this.client.getMessageContent(messageId).then(\n//       stream =>\n//         new Promise((resolve, reject) => {\n//           const writeable = fs.createWriteStream(downloadPath);\n//           stream.pipe(writeable);\n//           stream.on(\"end\", () => resolve(downloadPath));\n//           stream.on(\"error\", reject);\n//         })\n//     );\n//   }\n}\n"]}